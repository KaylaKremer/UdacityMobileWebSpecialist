'use strict';var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}(function(){function toArray(arr){return Array.prototype.slice.call(arr)}function promisifyRequest(request){return new Promise(function(resolve,reject){request.onsuccess=function(){resolve(request.result)};request.onerror=function(){reject(request.error)}})}function promisifyRequestCall(obj,method,args){var request;var p=new Promise(function(resolve,reject){request=obj[method].apply(obj,args);promisifyRequest(request).then(resolve,reject)});p.request=request;return p}function promisifyCursorRequestCall(obj,method,args){var p=promisifyRequestCall(obj,method,args);return p.then(function(value){if(!value)return;return new Cursor(value,p.request)})}function proxyProperties(ProxyClass,targetProp,properties){properties.forEach(function(prop){Object.defineProperty(ProxyClass.prototype,prop,{get:function get(){return this[targetProp][prop]},set:function set(val){this[targetProp][prop]=val}})})}function proxyRequestMethods(ProxyClass,targetProp,Constructor,properties){properties.forEach(function(prop){if(!(prop in Constructor.prototype))return;ProxyClass.prototype[prop]=function(){return promisifyRequestCall(this[targetProp],prop,arguments)}})}function proxyMethods(ProxyClass,targetProp,Constructor,properties){properties.forEach(function(prop){if(!(prop in Constructor.prototype))return;ProxyClass.prototype[prop]=function(){return this[targetProp][prop].apply(this[targetProp],arguments)}})}function proxyCursorRequestMethods(ProxyClass,targetProp,Constructor,properties){properties.forEach(function(prop){if(!(prop in Constructor.prototype))return;ProxyClass.prototype[prop]=function(){return promisifyCursorRequestCall(this[targetProp],prop,arguments)}})}function Index(index){this._index=index}proxyProperties(Index,'_index',['name','keyPath','multiEntry','unique']);proxyRequestMethods(Index,'_index',IDBIndex,['get','getKey','getAll','getAllKeys','count']);proxyCursorRequestMethods(Index,'_index',IDBIndex,['openCursor','openKeyCursor']);function Cursor(cursor,request){this._cursor=cursor;this._request=request}proxyProperties(Cursor,'_cursor',['direction','key','primaryKey','value']);proxyRequestMethods(Cursor,'_cursor',IDBCursor,['update','delete']);// proxy 'next' methods
['advance','continue','continuePrimaryKey'].forEach(function(methodName){if(!(methodName in IDBCursor.prototype))return;Cursor.prototype[methodName]=function(){var cursor=this;var args=arguments;return Promise.resolve().then(function(){cursor._cursor[methodName].apply(cursor._cursor,args);return promisifyRequest(cursor._request).then(function(value){if(!value)return;return new Cursor(value,cursor._request)})})}});function ObjectStore(store){this._store=store}ObjectStore.prototype.createIndex=function(){return new Index(this._store.createIndex.apply(this._store,arguments))};ObjectStore.prototype.index=function(){return new Index(this._store.index.apply(this._store,arguments))};proxyProperties(ObjectStore,'_store',['name','keyPath','indexNames','autoIncrement']);proxyRequestMethods(ObjectStore,'_store',IDBObjectStore,['put','add','delete','clear','get','getAll','getKey','getAllKeys','count']);proxyCursorRequestMethods(ObjectStore,'_store',IDBObjectStore,['openCursor','openKeyCursor']);proxyMethods(ObjectStore,'_store',IDBObjectStore,['deleteIndex']);function Transaction(idbTransaction){this._tx=idbTransaction;this.complete=new Promise(function(resolve,reject){idbTransaction.oncomplete=function(){resolve()};idbTransaction.onerror=function(){reject(idbTransaction.error)};idbTransaction.onabort=function(){reject(idbTransaction.error)}})}Transaction.prototype.objectStore=function(){return new ObjectStore(this._tx.objectStore.apply(this._tx,arguments))};proxyProperties(Transaction,'_tx',['objectStoreNames','mode']);proxyMethods(Transaction,'_tx',IDBTransaction,['abort']);function UpgradeDB(db,oldVersion,transaction){this._db=db;this.oldVersion=oldVersion;this.transaction=new Transaction(transaction)}UpgradeDB.prototype.createObjectStore=function(){return new ObjectStore(this._db.createObjectStore.apply(this._db,arguments))};proxyProperties(UpgradeDB,'_db',['name','version','objectStoreNames']);proxyMethods(UpgradeDB,'_db',IDBDatabase,['deleteObjectStore','close']);function DB(db){this._db=db}DB.prototype.transaction=function(){return new Transaction(this._db.transaction.apply(this._db,arguments))};proxyProperties(DB,'_db',['name','version','objectStoreNames']);proxyMethods(DB,'_db',IDBDatabase,['close']);// Add cursor iterators
// TODO: remove this once browsers do the right thing with promises
['openCursor','openKeyCursor'].forEach(function(funcName){[ObjectStore,Index].forEach(function(Constructor){// Don't create iterateKeyCursor if openKeyCursor doesn't exist.
if(!(funcName in Constructor.prototype))return;Constructor.prototype[funcName.replace('open','iterate')]=function(){var args=toArray(arguments);var callback=args[args.length-1];var nativeObject=this._store||this._index;var request=nativeObject[funcName].apply(nativeObject,args.slice(0,-1));request.onsuccess=function(){callback(request.result)}}})});// polyfill getAll
[Index,ObjectStore].forEach(function(Constructor){if(Constructor.prototype.getAll)return;Constructor.prototype.getAll=function(query,count){var instance=this;var items=[];return new Promise(function(resolve){instance.iterateCursor(query,function(cursor){if(!cursor){resolve(items);return}items.push(cursor.value);if(count!==undefined&&items.length==count){resolve(items);return}cursor.continue()})})}});var exp={open:function open(name,version,upgradeCallback){var p=promisifyRequestCall(indexedDB,'open',[name,version]);var request=p.request;if(request){request.onupgradeneeded=function(event){if(upgradeCallback){upgradeCallback(new UpgradeDB(request.result,event.oldVersion,request.transaction))}}}return p.then(function(db){return new DB(db)})},delete:function _delete(name){return promisifyRequestCall(indexedDB,'deleteDatabase',[name])}};if(typeof module!=='undefined'){module.exports=exp;module.exports.default=module.exports}else{self.idb=exp}})();/**
 * Common database helper functions.
 */var DBHelper=function(){function DBHelper(){_classCallCheck(this,DBHelper)}_createClass(DBHelper,null,[{key:'fetchRestaurants',/**
   * Fetches all restaurant reviews data. Creates an IndexedDB database named 'restaurant-reviews-db' with an object store of 'restaurant-reviews'. If response from the server is ok, stores data received into the database and then returns the data. If response from the server fails, look in the database to see if there is data already stored there and return the data. Catches and handles errors appropriately when data cannot be retrieved.
   */value:function fetchRestaurants(callback,id){var dbPromise=idb.open('restaurant-reviews-db',1,function(upgradeDB){switch(upgradeDB.oldVersion){case 0:upgradeDB.createObjectStore('restaurant-reviews',{keyPath:'id'});}});var restaurantURL=void 0;id?restaurantURL=DBHelper.DATABASE_URL+'/'+id:restaurantURL=''+DBHelper.DATABASE_URL;fetch(restaurantURL).then(function(response){if(response.ok){return response.json().then(function(restaurantReviews){dbPromise.then(function(db){var tx=db.transaction('restaurant-reviews','readwrite');var restaurantReviewsStore=tx.objectStore('restaurant-reviews');restaurantReviews.forEach(function(restaurantReview){restaurantReviewsStore.put(restaurantReview)});return tx.complete&&restaurantReviewsStore.getAll()}).then(function(restaurantReviews){console.log('Sucessfully fetched data from server & stored in IndexedDB!');callback(null,restaurantReviews)}).catch(function(error){callback('Failed to fetch data from server & store n IndexedDB: '+error,null)})})}else{dbPromise.then(function(db){var tx=db.transaction('restaurant-reviews','readonly');var restaurantReviewsStore=tx.objectStore('restaurant-reviews');//if (restaurantReviewsStores.getAll())
return tx.complete&&restaurantReviewsStore.getAll()}).then(function(restaurantReviews){console.log('Sucessfully fetched data from IndexedDB!');callback(null,restaurantReviews)}).catch(function(error){callback('Failed to fetch data from IndexedDB: '+error,null)})}}).catch(function(error){callback('Fetch request for data from server failed: '+error,null)})}/**
   * Fetch a restaurant by its ID.
   */},{key:'fetchRestaurantById',value:function fetchRestaurantById(id,callback){// fetch all restaurants with proper error handling.
DBHelper.fetchRestaurants(function(error,restaurants){if(error){callback(error,null)}else{var restaurant=restaurants.find(function(r){return r.id===parseInt(id)});if(restaurant){// Got the restaurant
callback(null,restaurant)}else{// Restaurant does not exist in the database
callback('Restaurant does not exist',null)}}})}/**
   * Fetch restaurants by a cuisine type with proper error handling.
   */},{key:'fetchRestaurantByCuisine',value:function fetchRestaurantByCuisine(cuisine,callback){// Fetch all restaurants  with proper error handling
DBHelper.fetchRestaurants(function(error,restaurants){if(error){callback(error,null)}else{// Filter restaurants to have only given cuisine type
var results=restaurants.filter(function(r){return r.cuisine_type==cuisine});callback(null,results)}})}/**
   * Fetch restaurants by a neighborhood with proper error handling.
   */},{key:'fetchRestaurantByNeighborhood',value:function fetchRestaurantByNeighborhood(neighborhood,callback){// Fetch all restaurants
DBHelper.fetchRestaurants(function(error,restaurants){if(error){callback(error,null)}else{// Filter restaurants to have only given neighborhood
var results=restaurants.filter(function(r){return r.neighborhood==neighborhood});callback(null,results)}})}/**
   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.
   */},{key:'fetchRestaurantByCuisineAndNeighborhood',value:function fetchRestaurantByCuisineAndNeighborhood(cuisine,neighborhood,callback){// Fetch all restaurants
DBHelper.fetchRestaurants(function(error,restaurants){if(error){callback(error,null)}else{var results=restaurants;if(cuisine!='all'){// filter by cuisine
results=results.filter(function(r){return r.cuisine_type==cuisine})}if(neighborhood!='all'){// filter by neighborhood
results=results.filter(function(r){return r.neighborhood==neighborhood})}callback(null,results)}})}/**
   * Fetch all neighborhoods with proper error handling.
   */},{key:'fetchNeighborhoods',value:function fetchNeighborhoods(callback){// Fetch all restaurants
DBHelper.fetchRestaurants(function(error,restaurants){if(error){callback(error,null)}else{// Get all neighborhoods from all restaurants
var neighborhoods=restaurants.map(function(v,i){return restaurants[i].neighborhood});// Remove duplicates from neighborhoods
var uniqueNeighborhoods=neighborhoods.filter(function(v,i){return neighborhoods.indexOf(v)==i});callback(null,uniqueNeighborhoods)}})}/**
   * Fetch all cuisines with proper error handling.
   */},{key:'fetchCuisines',value:function fetchCuisines(callback){// Fetch all restaurants
DBHelper.fetchRestaurants(function(error,restaurants){if(error){callback(error,null)}else{// Get all cuisines from all restaurants
var cuisines=restaurants.map(function(v,i){return restaurants[i].cuisine_type});// Remove duplicates from cuisines
var uniqueCuisines=cuisines.filter(function(v,i){return cuisines.indexOf(v)==i});callback(null,uniqueCuisines)}})}/**
   * Restaurant page URL.
   */},{key:'urlForRestaurant',value:function urlForRestaurant(restaurant){return'./restaurant.html?id='+restaurant.id}/**
   * Restaurant small image URL.
   */},{key:'smallImageUrlForRestaurant',value:function smallImageUrlForRestaurant(restaurant){return'/img/'+restaurant.photograph_small}/**
   * Restaurant large image URL.
   */},{key:'largeImageUrlForRestaurant',value:function largeImageUrlForRestaurant(restaurant){return'/img/'+restaurant.photograph_large}/**
   * Map marker for a restaurant.
   */},{key:'mapMarkerForRestaurant',value:function mapMarkerForRestaurant(restaurant,map){var marker=new google.maps.Marker({position:restaurant.latlng,title:restaurant.name,url:DBHelper.urlForRestaurant(restaurant),map:map,animation:google.maps.Animation.DROP});return marker}},{key:'DATABASE_URL',/**
   * Database URL.
   * Changed to retrieve data from the server on localhost:1337.
   */get:function get(){var port=1337;// Change this to your server port
return'http://localhost:'+port+'/restaurants'}}]);return DBHelper}();